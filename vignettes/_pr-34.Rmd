---
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  error = TRUE,
  collapse = TRUE
)
```

Avoid namespace to reduce distractions.

```{r}
library(tidyverse)
library(r2dii.match)
```

```{r}
data <- tribble(
  ~sector, ~technology, ~id_loan, ~loan_size_outstanding, ~production, ~year,
     "sa",         "ta",     "i1",                    40L,         10L, 2020L,
     "sa",         "ta",     "i2",                    10L,         30L, 2020L,
     "sa",         "tb",     "i1",                    40L,         20L, 2020L,
     "sa",         "tb",     "i2",                    10L,         40L, 2020L,
  )
```

> Loan 1 is 40, Loan 2 is 10. The sum here should be 50
>
> -- [Jackson](https://github.com/2DegreesInvesting/r2dii.analysis/pull/34#issuecomment-591640186)

* Compute the size of all loans in a sector. Beware of duplicated values of `loan_size*`.

```{r}
distinct_loans_by_sector <- data %>%  
  group_by(.data$sector) %>% 
  distinct(id_loan, loan_size_outstanding)

distinct_loans_by_sector
```

```{r echo=FALSE}
# check_unique_loan_size_values_per_id_loan
dups <- distinct_loans_by_sector %>% 
  group_by(.data$sector, .data$id_loan) %>% 
  mutate(is_duplicated = any(duplicated(id_loan))) %>% 
  ungroup() %>% 
  filter(is_duplicated)

if (nrow(dups) > 0L) {
  rlang::abort(
    class = "multiple_loan_size_values_by_id_loan",
    glue::glue(
      "Every `id_loan` by `sector` must have unique `loan_size*` values."
    )
  )
}

# TODO: Find out how to print the `dups` dataframe in the error message (maybe
# its head).
```

```{r}
loans_size_by_sector <- distinct_loans_by_sector %>% 
  summarize(loans_size = sum(.data$loan_size_outstanding))

loans_size_by_sector
```

* Add summary to original data

```{r}
data2 <- left_join(data, loans_size_by_sector, by = "sector")

data2
```

* Compute `loan_production_weighted_by_size_in_sector` (via the intermediate variable `loan_weight_by_size_in_sector`).

```{r}
result <- data2 %>% 
  mutate(
    loan_weight_by_size_in_sector = 
      .data$loan_size_outstanding / .data$loans_size,
    loan_production_weighted_by_size_in_sector = 
      .data$production * .data$loan_weight_by_size_in_sector
  )

result %>% glimpse()
```

I think this output is most informative and flexible. We could wrap it in, say, `add_loan_production_weighted_by_size_in_sector()`.

The user may be interested in a specific summary, which granularity depends only on which variables they include in the call to `group_by()`, for example:

```{r}
result %>% 
  group_by(.data$sector, .data$technology, .data$year) %>%
  summarize(
    weighted_production = sum(.data$loan_production_weighted_by_size_in_sector)
  )
```

We may also wrap the two lines above, or replace the call to `summarize()` with a call to `mutate()` (which duplicates `weighted_production` values):

```{r}
result %>% 
  group_by(.data$sector, .data$technology, .data$year) %>%
  mutate(
    weighted_production = sum(.data$loan_production_weighted_by_size_in_sector)
  ) %>% 
  glimpse()
```

